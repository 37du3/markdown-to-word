# Markdown 转 Word 格式转换工具 - 设计文档

## 1 项目概述

### 1.1 项目背景

随着大语言模型（LLM）的广泛应用，如 ChatGPT、Claude、Gemini、通义千问等，用户经常需要将这些模型输出的内容复制到 Word、Notion、飞书等文档工具中。然而，LLM 的输出通常采用 Markdown 格式，直接复制粘贴会导致格式丢失或显示混乱，尤其是表格、代码块、嵌套列表等复杂结构。本项目旨在开发一个纯前端的 Web 工具，帮助用户将 Markdown 内容转换为 Word 友好格式，解决格式兼容性问题。

当前市场上虽然存在一些 Markdown 编辑器和转换工具，但它们往往功能过于复杂，学习成本高，且不支持实时预览和多种输出格式。本项目将专注于核心转换功能，提供简洁的用户体验，同时保持完全开源和隐私安全。所有转换操作均在浏览器本地完成，用户的文本数据不会被上传到任何服务器，这在大模型应用场景中对隐私保护尤为重要。

### 1.2 项目目标

本项目的核心目标是构建一个轻量级、易用且功能强大的 Markdown 格式转换工具。具体而言，项目需要实现以下目标：首先，提供流畅的文本输入体验，支持用户将大模型输出的 Markdown 内容快速粘贴到输入框中；其次，实现高质量的格式转换，将 Markdown 语法精确转换为 Word 可识别的富文本格式，支持表格（含合并单元格）、代码块、格式化文本、图片、列表、标题等元素；第三，提供灵活的输出方式，用户既可以一键复制转换后的内容，也可以直接下载为 .docx 格式文件；最后，确保项目的开源性和可扩展性，为社区贡献者提供清晰的代码结构和文档支持。

### 1.3 目标用户

本项目的主要用户群体包括以下几类：第一类是经常使用大语言模型的开发者和内容创作者，他们需要将 AI 生成的技术文档、代码说明等内容整理到正式文档中；第二类是研究人员和学生，他们需要将 AI 辅助生成的研究资料整理成规范的学术文档；第三是企业用户，他们需要将 AI 生成的项目报告、需求文档等内容整合到公司文档体系中。无论用户的技术背景如何，本项目都将提供简洁直观的操作界面，降低使用门槛。

## 2 功能需求

### 2.1 核心功能

本项目围绕 Markdown 到 Word 格式转换这一核心需求，设计了四个相互关联的核心功能模块，共同构成完整的用户体验闭环。

输入功能模块负责接收用户的 Markdown 文本。考虑到大模型输出的多样性，输入区域需要支持大容量的文本粘贴，同时提供基本的文本编辑能力，如撤销、重做、全选等。输入区域还应该实时显示文本统计信息，包括字符数、行数等，帮助用户了解输入内容的规模。此外，为了提升用户体验，可以考虑在用户粘贴时自动检测并清理多余的空行、统一换行符格式等。

转换功能模块是整个系统的核心，负责将 Markdown 语法解析并转换为目标格式。该模块需要处理六类主要的 Markdown 元素：标题（支持 H1 到 H6 六级标题）、格式化文本（支持粗体、斜体、下划线、高亮等样式）、列表（支持有序列表、无序列表和嵌套列表）、代码块（支持行内代码和块级代码，保留语法高亮信息）、图片（支持行内图片和引用图片，转换为 Word 可识别的格式）以及最复杂的表格（支持标准表格、表头对齐、单元格合并等特性）。每个元素类型都需要精确的转换逻辑，确保在 Word 中能够正确显示。

输出功能模块提供两种获取转换结果的方式。第一种是复制到剪贴板功能，用户点击按钮后，转换后的内容将以 HTML 富文本格式复制到系统剪贴板，用户可以直接粘贴到 Word、Notion、飞书等工具中。复制功能需要处理多种剪贴板格式以确保兼容性，同时提供复制成功或失败的反馈。第二种是下载 .docx 文件功能，使用 docx.js 库生成标准 Word 文档，用户可以下载后在本地编辑。下载功能需要处理文件命名、大小限制等边界情况。

预览功能模块让用户在转换前就能看到最终效果。左侧输入区域和右侧预览区域采用分屏布局，实时显示 Markdown 原文和对应的 Word 风格预览。预览区域需要尽可能模拟 Word 的显示效果，包括字体、字号、行距、表格边框等样式。当用户修改输入内容时，预览应该自动更新（可以考虑添加防抖优化）。

### 2.2 非功能性需求

除了核心功能，本项目还需要满足一系列非功能性需求，以确保产品质量和用户体验。在性能方面，转换操作应该在 500ms 内完成，即使是复杂的 Markdown 文档（如包含大量表格和代码块）也不应超过 2 秒。输入和预览应该保持流畅，不出现明显的卡顿。在浏览器兼容性方面，项目需要支持主流浏览器的最新两个主要版本，包括 Chrome、Firefox、Safari 和 Edge。在响应式设计方面，界面应该适配桌面端和移动端，在不同屏幕尺寸下都能正常使用。

在隐私安全方面，这是本项目的核心承诺之一。所有转换操作必须在浏览器本地完成，不能将用户的文本内容发送到任何服务器。项目中不能包含任何用户行为追踪、数据收集或分析功能。在代码安全方面，需要遵循前端安全最佳实践，防止 XSS 攻击等安全漏洞。在可访问性方面，界面需要满足 WCAG 2.1 AA 级标准，确保视障用户可以使用屏幕阅读器正常操作。

## 3 技术架构

### 3.1 整体架构

本项目采用纯前端架构，所有业务逻辑和数据处理都在浏览器中完成。这种架构选择基于以下考量：首先，Markdown 解析和格式转换完全可以在客户端完成，无需服务器支持；其次，纯前端架构简化了部署流程，可以利用 CDN 和静态托管服务；第三，用户的文本数据完全保存在本地，不经过任何服务器，从根本上保护了用户隐私。

系统的整体架构分为四层：表现层负责用户界面的渲染和交互，包括输入区域、预览区域、控制按钮等 UI 组件；应用层负责协调各模块的工作，处理用户输入事件、管理状态、执行转换逻辑；解析层负责 Markdown 语法的解析和 AST 的生成，使用成熟的开源库确保解析质量；输出层负责将解析结果转换为目标格式，包括 HTML 富文本和 .docx 文件两种输出。

### 3.2 技术选型

技术栈的选择遵循以下原则：优先选择成熟稳定的开源库，确保项目的长期可维护性；优先选择 TypeScript 友好的库，获得类型检查支持；优先选择体积适中、性能优良的库，避免给用户带来额外的加载负担。

| 层次 | 技术选型 | 选型理由 |
|------|---------|----------|
| 框架 | React 18 | 组件化架构成熟，生态完善，TypeScript 支持良好 |
| 语言 | TypeScript 5 | 静态类型检查减少运行时错误，代码可维护性高 |
| 构建 | Vite 5 | 开发体验优秀，热更新快速，生产构建优化良好 |
| Markdown 解析 | marked 12 | 轻量级、速度快、AST 输出格式清晰、社区活跃 |
| Word 生成 | docx 8 | 功能完整、支持复杂表格、TypeScript 类型完善 |
| 样式 | Tailwind CSS 3 | 开发效率高、原子化 CSS 减少样式冲突、按需编译体积小 |
| 图标 | Lucide React | 图标风格统一、TypeScript 支持、可按需引入 |
| 测试 | Vitest + React Testing Library | 与 Vite 集成良好，测试体验流畅 |

### 3.3 项目结构

项目采用标准的 React + TypeScript 项目结构，同时针对格式转换工具的特点进行适当调整。src 目录包含所有源代码，其中 components 目录存放 React 组件，按照功能划分为 Editor（编辑器组件）、Preview（预览组件）、Controls（控制组件）等子目录；utils 目录存放工具函数，包括 Markdown 解析器、格式转换器、剪贴板操作等；types 目录存放 TypeScript 类型定义，确保跨模块的类型安全；hooks 目录存放自定义 Hook，封装可复用的逻辑。

根目录下的主要配置文件包括 package.json（定义依赖和脚本）、tsconfig.json（TypeScript 编译配置）、vite.config.ts（Vite 构建配置）、tailwind.config.js（Tailwind CSS 配置）、.eslintrc.js（ESLint 配置）和 .prettierrc（代码格式化配置）。tests 目录存放测试文件，采用与 src 目录对应的结构。docs 目录存放项目文档，包括设计文档、API 文档、贡献指南等。public 目录存放静态资源，如 favicon、图标文件等。

```
v0/
├── public/
│   └── favicon.ico
├── src/
│   ├── components/
│   │   ├── Editor/
│   │   │   ├── MarkdownInput.tsx
│   │   │   └── Toolbar.tsx
│   │   ├── Preview/
│   │   │   ├── WordPreview.tsx
│   │   │   └── TableRenderer.tsx
│   │   ├── Controls/
│   │   │   ├── CopyButton.tsx
│   │   │   └── DownloadButton.tsx
│   │   └── Layout/
│   │       ├── Header.tsx
│   │       └── SplitPane.tsx
│   ├── utils/
│   │   ├── parser/
│   │   │   ├── MarkdownParser.ts
│   │   │   └── TableProcessor.ts
│   │   ├── converter/
│   │   │   ├── HtmlConverter.ts
│   │   │   └── DocxConverter.ts
│   │   └── clipboard/
│   │       └── ClipboardUtils.ts
│   ├── types/
│   │   ├── markdown.ts
│   │   ├── document.ts
│   │   └── index.ts
│   ├── hooks/
│   │   ├── useDebounce.ts
│   │   └── useConversion.ts
│   ├── App.tsx
│   └── main.tsx
├── tests/
│   ├── parser/
│   ├── converter/
│   └── e2e/
├── docs/
│   └── plans/
├── package.json
├── tsconfig.json
├── vite.config.ts
├── tailwind.config.js
├── .eslintrc.js
└── README.md
```

## 4 核心模块设计

### 4.1 Markdown 解析模块

Markdown 解析模块负责将用户输入的 Markdown 文本转换为抽象语法树（AST），为后续的格式转换提供结构化的数据表示。该模块是整个转换流程的起点，其解析质量直接影响最终的输出效果。

模块的核心是 MarkdownParser 类，它封装了 marked 库的调用，提供更友好的 API。Parser 的主要方法包括 parse（将 Markdown 解析为 AST）、parseInline（仅解析行内元素，用于处理粗体、斜体等）和 getStats（获取解析统计信息，如元素数量、层级深度等）。Parser 还会对解析结果进行后处理，如检测并标记表格元素（marked 库默认不解析表格，需要使用表格插件）、处理代码块的语法高亮信息等。

TableProcessor 是解析模块中专门处理表格的辅助类。Markdown 表格语法相对简单，不支持合并单元格，但实际的表格数据往往需要合并单元格来更好地呈现信息。因此，TableProcessor 实现了两个方向的处理：从 Markdown AST 提取表格信息时，需要正确解析表头分隔行中的对齐标记；在生成输出格式时，需要将简单的表格结构转换为支持合并单元格的复杂结构。该类还负责检测表格的边界、验证表格格式的正确性、处理表格中的特殊字符等。

解析模块的错误处理策略是：对于可以恢复的解析错误（如不完整的语法、缺少的标记等），记录警告信息并尽可能继续解析；对于严重的解析错误（如循环依赖、内存溢出等），抛出异常并显示友好的错误提示。解析过程中的所有警告和错误都会被收集并传递给应用层，用于在 UI 上显示诊断信息。

### 4.2 格式转换模块

格式转换模块是系统的核心，负责将 Markdown AST 转换为目标格式。该模块包含两个主要的转换器：HtmlConverter 用于生成 HTML 富文本，DocxConverter 用于生成 .docx 文档。

HtmlConverter 的设计理念是生成「所见即所得」的 HTML 代码，使得复制到剪贴板后能够在 Word 等编辑器中正确显示。Converter 将 AST 中的每个节点转换为对应的 HTML 元素，并添加适当的样式属性以模拟 Word 的显示效果。转换规则遵循以下原则：标题使用 h1 到 h6 标签，并添加内联的 font-size 和 font-weight 样式；粗体使用 strong 或 b 标签，斜体使用 em 或 i 标签；代码块使用 pre 和 code 标签，保留等宽字体；表格使用 table、thead、tbody、tr、td 等标签，并添加 border-collapse 和 border 样式以显示表格边框。

表格转换是 HtmlConverter 中最复杂的部分。Markdown 表格语法不支持合并单元格，但在实际应用中，用户可能需要在输出中合并某些单元格。考虑到这一需求，HtmlConverter 实现了可配置的合并策略：默认情况下，保持表格的原始结构；如果用户需要合并单元格，可以通过特殊语法（如在表格中使用特定的标记）或 UI 操作来指定合并区域。转换器会检查合并请求的合法性（如合并区域必须是矩形、不能跨表头等），然后生成包含 rowspan 和 colspan 属性的 HTML 表格。

DocxConverter 使用 docx.js 库生成 .docx 格式的 Word 文档。相比 HTML 转换，DocxConverter 需要更严格地遵循 Word 文档的规范。转换器将 AST 节点映射到 docx.js 的文档模型，包括 Paragraph（段落）、TextRun（文本运行）、Table（表格）、TableCell（表格单元格）等组件。样式通过 ParagraphStyle、TextRunStyle 等对象传递，支持字体、字号、颜色、对齐方式、行距等丰富的样式选项。DocxConverter 还支持生成文档的元数据，如标题、作者、创建日期等。

HtmlConverter 和 DocxConverter 共享一套转换规则定义，确保两种输出格式的一致性。转换规则使用策略模式实现，可以通过配置切换不同的规则集，满足用户对不同输出风格的偏好。

### 4.3 剪贴板模块

剪贴板模块负责将转换后的内容复制到系统剪贴板，这是用户最常用的输出方式之一。由于不同应用对剪贴板内容的格式要求不同，剪贴板模块需要同时写入多种格式，以确保在各种目标应用中的兼容性。

模块的核心是 ClipboardUtils 工具类，它封装了浏览器 Clipboard API 的调用。Clipboard API 提供了 write 和 read 两类操作，分别用于写入和读取剪贴板内容。写入操作支持多种 MIME 类型，本模块主要使用以下几种：text/html 用于粘贴到支持富文本的应用（如 Word、飞书）；text/plain 用于粘贴到纯文本编辑器；text/rtf 用于粘贴到支持 RTF 的应用。

复制操作的执行流程如下：首先，HtmlConverter 生成目标 HTML 代码；然后，ClipboardUtils 将 HTML 包装为 ClipboardItem 对象，同时设置 text/html 和 text/plain 两种格式；最后，调用 navigator.clipboard.write() 方法写入剪贴板。如果浏览器不支持 Clipboard API（某些情况下），模块会降级到传统的 document.execCommand('copy') 方法作为备选方案。

剪贴板模块还需要处理用户权限问题。Clipboard API 需要用户授权才能访问剪贴板，模块需要在首次使用时请求授权，并妥善处理用户拒绝的情况。对于安全上下文（HTTPS）的要求，模块会在初始化时检测当前环境是否满足要求，如果不满足会显示相应的提示信息。

### 4.4 用户界面模块

用户界面模块负责呈现友好的交互界面，引导用户完成输入、转换和输出的整个流程。界面采用响应式设计，在不同屏幕尺寸下都能提供良好的使用体验。

整体布局采用经典的三栏结构：左侧是 Markdown 输入区域，提供大容量的文本编辑空间；中间是功能控制栏，放置复制按钮、下载按钮和设置选项；右侧是实时预览区域，显示转换后的效果预览。用户可以通过拖拽调整左右两侧的宽度比例，以适应不同的使用习惯和屏幕尺寸。在移动设备上，三栏布局会自动调整为单栏堆叠，输入区域和预览区域上下排列。

MarkdownInput 组件是输入区域的核心，提供基础的文本编辑功能。组件使用 React 的 controlled 模式管理输入内容，响应用户的键盘和鼠标操作。为了提供更好的编辑体验，组件实现了以下功能：自动缩进、制表符处理、括号匹配、滚动同步（与预览区域同步滚动）。组件还会在用户输入时进行基本的 Markdown 语法检查，高亮显示语法错误，但不会阻止用户输入。

Toolbar 组件提供一组快捷操作按钮，包括常见的格式化操作（如插入粗体、斜体、代码块标记等）、撤销和重做按钮、以及清空按钮。这些按钮通过插入或包裹文本来工作，不需要用户手动输入 Markdown 语法标记。Toolbar 的设计注重可发现性，每个按钮都有 Tooltip 提示其功能和使用方法。

Preview 组件负责渲染转换后的内容预览。组件接收 HtmlConverter 的输出，并将其嵌入到预览容器中显示。预览的样式经过精心调整，尽可能模拟 Word 的显示效果，包括默认字体（宋体或 Calibri）、字号（正文 12pt、标题不同层级不同大小）、行距（1.5 倍或固定值）、段落间距等。用户可以通过设置面板调整预览样式，以适应不同的目标文档格式。

## 5 数据流程

### 5.1 转换流程

用户输入的 Markdown 文本经过以下流程转换为可输出的格式：

```
用户输入 → 文本预处理 → Markdown 解析 → AST 后处理 → 格式转换 → 输出生成
```

文本预处理阶段对原始输入进行规范化处理，包括：将不同类型的换行符（CRLF、LF、CR）统一为 LF；合并连续的空行（可配置合并规则）；处理特殊字符的转义；检测并标记代码块的语言类型。预处理的目标是生成「干净」的 Markdown 输入，减少解析阶段的错误。

Markdown 解析阶段使用 marked 库将预处理后的文本解析为 AST。解析过程会产生一系列事件（如遇到标题、遇到代码块等），AST 后处理器会监听这些事件，进行额外的处理，如表格格式验证、代码块语法高亮提取、链接有效性检查等。后处理的结果是一个增强的 AST，包含更丰富的元数据。

格式转换阶段遍历增强的 AST，根据节点类型调用相应的转换函数。每个转换函数负责将特定类型的节点（如标题、段落、列表、表格等）转换为目标格式的表示。转换过程中会维护上下文信息，如当前标题层级、当前列表深度、当前表格状态等，确保转换结果的正确性。

输出生成阶段将转换结果封装为最终的可输出格式。HTML 格式直接输出为字符串；.docx 格式使用 docx.js 库生成文档对象，然后打包为二进制文件。两种格式的生成过程相互独立，但都基于相同的转换结果，确保输出一致性。

### 5.2 状态管理

本项目使用 React 的 useState 和 useReducer 进行本地状态管理，对于复杂的状态逻辑使用 Context 进行跨组件共享。整个应用的状态可以分为三类：用户输入状态（Markdown 文本内容）、转换状态（转换进度、结果、错误）和 UI 状态（设置面板开关、布局配置、主题等）。

用户输入状态使用 debounced 方式传递给转换模块，避免在用户快速输入时频繁触发转换。debounce 的延迟时间设置为 300ms，在响应速度和性能之间取得平衡。用户停止输入 300ms 后，转换模块才开始工作，转换完成后更新预览状态。

转换状态包含转换结果缓存，用于避免不必要的重复转换。当用户输入经过 debounce 后，转换模块会检查输入内容是否与上次转换时相同，如果相同则直接使用缓存结果，否则执行新的转换。这种优化可以显著减少在用户快速编辑时的计算开销。

错误状态采用统一的管理方式，所有模块在遇到可恢复错误时将错误信息添加到错误状态中，UI 层根据错误状态显示相应的提示。错误信息包含错误类型、错误消息、发生位置和修复建议，帮助用户理解问题并采取行动。

## 6 错误处理

### 6.1 错误分类

系统可能遇到的错误可以分为以下几类：

解析错误发生在 Markdown 解析阶段，包括语法错误（如不完整的代码块标记）、格式错误（如表格缺少表头分隔行）和编码错误（如包含无法解码的字符）。大多数解析错误可以定位到具体的行和列，系统会提供精确的错误位置信息，帮助用户定位问题。

转换错误发生在格式转换阶段，通常是由于 AST 结构不符合预期导致的。例如，尝试合并不存在的单元格、嵌套层级超过限制、样式配置冲突等。转换错误需要立即终止转换并回滚到上一个有效状态。

系统错误发生在浏览器环境不支持某些 API 或资源时，如 Clipboard API 不可用、内存不足、浏览器版本过低等。系统错误通常无法通过应用层逻辑恢复，需要向用户说明情况并提供替代方案。

### 6.2 错误处理策略

对于不同类型的错误，系统采用不同的处理策略：

可恢复错误（如某些解析警告）不会中断转换流程，而是记录到警告日志中，并在 UI 上以非侵入式的方式显示（如在状态栏显示警告图标）。用户可以选择忽略警告，或点击查看详细信息并采取修复措施。

不可恢复错误（如严重的解析错误、系统错误）会中断当前操作，UI 上显示错误提示，并提供重试按钮。对于解析错误，提示信息会包含错误位置和可能的修复建议；对于系统错误，提示信息会包含错误原因和替代方案说明。

边界情况处理是错误处理的重要组成部分。空输入、极长的行、嵌套过深的列表、超大文件等边界情况都需要特别处理。系统会设置合理的限制（如最大输入长度、最大表格尺寸等），当超出限制时显示明确的提示，而不是静默失败或崩溃。

## 7 测试策略

### 7.1 测试层次

项目采用多层次的测试策略，确保代码质量和功能正确性：

单元测试针对单个函数和工具类进行测试，使用 Vitest 作为测试框架。测试覆盖所有 utils 目录下的函数，包括 Markdown 解析器、格式转换器、剪贴板工具等。单元测试重点关注边界情况、异常输入和核心逻辑的正确性。

集成测试针对组件的交互逻辑进行测试，使用 React Testing Library 进行测试。测试覆盖所有 components 目录下的组件，重点测试组件之间的协作、状态更新的正确性和用户交互的响应。集成测试使用模拟的数据和事件，确保测试的确定性和可重复性。

端到端测试针对完整的用户流程进行测试，使用 Playwright 进行测试。端到端测试覆盖核心用户场景，如「输入 Markdown → 预览更新 → 复制内容 → 粘贴验证」和「输入 Markdown → 下载文件 → 打开文件验证」。端到端测试在真实的浏览器环境中运行，确保整个系统的正确性。

### 7.2 测试数据

测试数据是测试策略的重要组成部分，项目需要准备以下几类测试数据：

基础测试数据包含各种基本的 Markdown 元素示例，如不同层级的标题、各种样式的文本、各类列表、简单的表格和代码块。这些数据用于验证基础的解析和转换功能是否正确。

复杂测试数据包含大模型输出的典型内容，如包含大量表格的技术文档、嵌套多层的列表结构、包含图片和链接的分析报告等。这些数据用于验证系统在复杂场景下的表现。

边界测试数据包含极端情况，如超长的单行文本、空输入、超大的表格（测试性能限制）、包含特殊字符的文本等。这些数据用于验证系统的健壮性。

预期输出数据是测试数据的配套资源，包含每组测试数据对应的预期输出（HTML 和 .docx）。测试时会将实际输出与预期输出进行对比，验证转换的正确性。

## 8 后续计划

### 8.1 版本规划

第一阶段（MVP）将实现核心转换功能，包括基础的 Markdown 解析、表格转换、HTML 富文本复制和 .docx 下载。目标是让用户能够完成基本的格式转换任务。

第二阶段将增强功能和优化体验，包括支持更多 Markdown 语法（如脚注、定义列表、Mermaid 图表等）、优化表格转换（支持合并单元格的交互式编辑）、添加主题和样式自定义选项。

第三阶段将扩展平台支持，包括开发 Chrome 扩展程序（解决页面适配问题）和桌面应用（使用 Electron 技术），让用户可以在不同场景下使用本工具。

### 8.2 开源运营

作为开源项目，需要制定清晰的运营策略：

代码管理方面，使用 GitHub 作为代码托管平台，采用 Git Flow 或 Trunk Based Development 工作流。所有代码变更都需要通过 Pull Request 审核后才能合并，确保代码质量。

文档建设方面，维护完整的 README、CONTRIBUTING、API 文档和使用指南。文档使用 Markdown 编写，与代码仓库同步管理。

社区运营方面，建立 Discord 或 Slack 社区用于交流，设立 Issues 收集用户反馈和功能请求，使用 Discussions 进行更开放的讨论。对于贡献者，提供明确的贡献指南和「首次贡献」标签的任务。

发布管理方面，使用语义化版本号（Semantic Versioning），保持 CHANGELOG 的更新。每次发布都生成对应的 GitHub Release，包含更新说明和构建产物。

---

本文档定义了项目的整体架构和设计方向，后续会根据开发进展进行更新和完善。如有任何问题或建议，欢迎提交 Issue 讨论。
